using Minecraft.Implementations.Tags;
using Minecraft.Packets;
using Minecraft.Schemas;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Parameters;

namespace Minecraft.Implementations;

/// <summary>
/// Represents a connection to or from a Minecraft server.
/// Supports sending and receiving packets.
/// </summary>
public abstract class MinecraftConnection : ITaggable {
    /// <summary>
    /// The protocol state of the connection. None means we are pre handshake.
    /// </summary>
    public ConnectionState State = ConnectionState.None;
    
    /// <summary>
    /// Whether compression is enabled.
    /// To enable compression set <see cref="CompressionThreshold"/> to a value >= 0.
    /// To disable compression set <see cref="CompressionThreshold"/> to -1.
    /// </summary>
    public bool CompressionEnabled => CompressionThreshold >= 0;
    
    /// <summary>
    /// The minimum size of a packet before compression is used.
    /// </summary>
    /// <remarks>
    /// This setting should not be enabled without negotiating it with the other party.
    /// Otherwise, the other party will not know to compress/decompress the packets.
    /// </remarks>
    public int CompressionThreshold = -1;
    
    /// <summary>
    /// Whether packets should be encrypted.
    /// If this is true, the <see cref="Decryptor"/> and <see cref="Encryptor"/> must be set.
    /// They can be set using <see cref="CreateSymAes"/>.
    /// </summary>
    /// <remarks>
    /// This setting should not be enabled without negotiating it with the other party.
    /// Otherwise, the other party will not be able to decrypt the packets.
    /// </remarks>
    public bool EncryptionEnabled = false;
    public BufferedBlockCipher? Decryptor;
    public BufferedBlockCipher? Encryptor;
    public byte[]? SharedSecret;
    
    /// <summary>
    /// Whether to allow unknown packets to be received without throwing an exception.
    /// </summary>
    /// <seealso cref="UnknownPacket"/>
    public bool AllowUnknownPackets = false;
    
    /// <summary>
    /// Event that is invoked when the connection is disconnected.
    /// </summary>
    public event Action? Disconnected;
    private readonly Dictionary<string, object?> Data = new();  // tag data
    
    /// <summary>
    /// Invokes the <see cref="Disconnected"/> event.
    /// Implementations should call this when the connection is disconnected.
    /// </summary>
    protected void InvokeDisconnected() {
        Disconnected?.Invoke();
    }
    
    /// <summary>
    /// Create a symmetric AES cipher for use with the Minecraft protocol.
    /// </summary>
    /// <param name="sharedSecret">The shared secret generated by the client.</param>
    /// <param name="encrypt">Whether the cipher should be for encrypting, else for decrypting.</param>
    /// <returns>The cipher.</returns>
    public static BufferedBlockCipher CreateSymAes(byte[] sharedSecret, bool encrypt) {
        // Create a CFB8 cipher with AES
        BufferedBlockCipher cipher = new (new CfbBlockCipher(new AesEngine(), 8));
        cipher.Init(encrypt, new ParametersWithIV(new KeyParameter(sharedSecret), sharedSecret));
        return cipher;
    }
    
#region packets
    public async Task SendPackets(bool sequentially, params MinecraftPacket[] packets) {
        foreach (MinecraftPacket packet in packets) {
            if (sequentially) {
                await SendPacket(packet);
            }
            else {
                _ = SendPacket(packet);
            }
        }
    }
    
    public Task SendPackets(params MinecraftPacket[] packets) {
        return SendPackets(true, packets);
    }

    public virtual Task SendPacket(MinecraftPacket packet) {
        return SendPacketInternal(packet);
    }
#endregion
    
#region util_methods
    protected void Log(string s) {
        Console.WriteLine($"[{this.GetType().FullName}] [{State}] {s}");
    }
    
    public T GetTag<T>(Tag<T> tag) {
        return (T)Data[tag.Id]!;
    }

    public bool HasTag<T>(Tag<T> tag) {
        return Data.ContainsKey(tag.Id);
    }

    public void SetTag<T>(Tag<T> tag, T value) {
        Data[tag.Id] = value;
    }
    
#endregion

#region implementation_methods

    protected abstract Task SendPacketInternal(MinecraftPacket packet);
        
    /// <summary>
    /// Tell the implementation to initialise the encryption streams.
    /// After encryption is enabled and the Encryptor and Decryptor are set,
    /// this method should be invoked.
    /// </summary>
    public abstract void InitialiseEncryption();
        
    /// <summary>
    /// Start handling incoming packets from the client.
    /// </summary>
    /// <returns></returns>
    public abstract Task HandlePackets();
        
    /// <summary>
    /// Terminates the connection. This will not send any packets to the client.
    /// </summary>
    public abstract void Disconnect();

#endregion
}
